import Foundation

class EncounterStorage {
    static let shared = EncounterStorage()
    
    private let basePath: URL
    private let estTimeZone: TimeZone
    
    init() {
        basePath = FileManager.default.homeDirectoryForCurrentUser
            .appendingPathComponent("Desktop")
            .appendingPathComponent("ClinAssist")
        
        // EST timezone
        estTimeZone = TimeZone(identifier: "America/New_York") ?? TimeZone.current
        
        // Ensure directories exist
        try? FileManager.default.createDirectory(
            at: basePath.appendingPathComponent("encounters"),
            withIntermediateDirectories: true
        )
        try? FileManager.default.createDirectory(
            at: basePath.appendingPathComponent("temp"),
            withIntermediateDirectories: true
        )
        try? FileManager.default.createDirectory(
            at: basePath.appendingPathComponent("Daily Record"),
            withIntermediateDirectories: true
        )
    }
    
    // MARK: - Save Encounter
    
    func saveEncounter(_ state: EncounterState, soapNote: String, keepAudio: Bool = false) throws -> URL {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let folderName = dateFormatter.string(from: state.startedAt)
        
        let encounterPath = basePath
            .appendingPathComponent("encounters")
            .appendingPathComponent(folderName)
        
        try FileManager.default.createDirectory(at: encounterPath, withIntermediateDirectories: true)
        
        // Save encounter.json
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601
        
        let encounterJSON = try encoder.encode(state)
        try encounterJSON.write(to: encounterPath.appendingPathComponent("encounter.json"))
        
        // Save transcript.txt
        let transcriptText = state.transcript
            .map { "[\(formatTimestamp($0.timestamp))] \($0.speaker): \($0.text)" }
            .joined(separator: "\n\n")
        try transcriptText.write(
            to: encounterPath.appendingPathComponent("transcript.txt"),
            atomically: true,
            encoding: .utf8
        )
        
        // Save soap_note.txt
        try soapNote.write(
            to: encounterPath.appendingPathComponent("soap_note.txt"),
            atomically: true,
            encoding: .utf8
        )
        
        // Handle audio files
        let tempAudioPath = basePath
            .appendingPathComponent("temp")
            .appendingPathComponent(state.id.uuidString)
        
        if keepAudio {
            let audioDestPath = encounterPath.appendingPathComponent("audio")
            try? FileManager.default.moveItem(at: tempAudioPath, to: audioDestPath)
        } else {
            try? FileManager.default.removeItem(at: tempAudioPath)
        }
        
        return encounterPath
    }
    
    // MARK: - Daily Record
    
    func appendToDailyRecord(state: EncounterState, soapNote: String, patientIdentifier: String) {
        let dailyRecordPath = basePath.appendingPathComponent("Daily Record")
        
        // Create filename with date and day name (e.g., "2025-11-27_Thursday.txt")
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = estTimeZone
        dateFormatter.dateFormat = "yyyy-MM-dd_EEEE"
        let filename = dateFormatter.string(from: state.startedAt) + ".txt"
        
        let filePath = dailyRecordPath.appendingPathComponent(filename)
        
        // Format times in EST
        let timeFormatter = DateFormatter()
        timeFormatter.timeZone = estTimeZone
        timeFormatter.dateFormat = "h:mm a"
        
        let startTime = timeFormatter.string(from: state.startedAt)
        let endTime = timeFormatter.string(from: state.endedAt ?? Date())
        
        // Build the entry
        let separator = "========================================"
        let entry = """
        
        \(separator)
        Patient: \(patientIdentifier)
        Time: \(startTime) - \(endTime)
        \(separator)
        
        \(soapNote)
        
        
        """
        
        // Append to file (create if doesn't exist)
        if FileManager.default.fileExists(atPath: filePath.path) {
            // Append to existing file
            if let fileHandle = try? FileHandle(forWritingTo: filePath) {
                fileHandle.seekToEndOfFile()
                if let data = entry.data(using: .utf8) {
                    fileHandle.write(data)
                }
                fileHandle.closeFile()
            }
        } else {
            // Create new file with header
            let header = """
            Daily Record - \(dateFormatter.string(from: state.startedAt).replacingOccurrences(of: "_", with: " "))
            Generated by ClinAssist
            
            """
            let fullContent = header + entry
            try? fullContent.write(to: filePath, atomically: true, encoding: .utf8)
        }
    }
    
    func extractPatientIdentifier(from soapNote: String) -> String {
        // Extract patient identifier from SOAP note
        // Looks for "PATIENT: Name" header lines
        
        let lines = soapNote.components(separatedBy: .newlines)
        var identifiers: [String] = []
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let uppercaseLine = trimmedLine.uppercased()
            
            // Check for "PATIENT:" header format
            if uppercaseLine.hasPrefix("PATIENT:") {
                let identifier = trimmedLine
                    .replacingOccurrences(of: "PATIENT:", with: "", options: .caseInsensitive)
                    .trimmingCharacters(in: .whitespaces)
                if !identifier.isEmpty {
                    identifiers.append(identifier)
                }
            }
        }
        
        // Remove duplicates while preserving order
        var seen = Set<String>()
        identifiers = identifiers.filter { seen.insert($0.lowercased()).inserted }
        
        if identifiers.isEmpty {
            return "Unknown Patient"
        } else if identifiers.count == 1 {
            return identifiers[0]
        } else {
            // Multiple patients - join them
            return identifiers.enumerated()
                .map { "(\($0.offset + 1)) \($0.element)" }
                .joined(separator: "; ")
        }
    }
    
    // MARK: - Clean Up Temp
    
    func cleanupTempFolder(for encounterId: UUID) {
        let tempPath = basePath
            .appendingPathComponent("temp")
            .appendingPathComponent(encounterId.uuidString)
        
        try? FileManager.default.removeItem(at: tempPath)
    }
    
    func cleanupAllTemp() {
        let tempPath = basePath.appendingPathComponent("temp")
        
        guard let contents = try? FileManager.default.contentsOfDirectory(
            at: tempPath,
            includingPropertiesForKeys: nil
        ) else { return }
        
        for item in contents {
            try? FileManager.default.removeItem(at: item)
        }
    }
    
    // MARK: - List Past Encounters
    
    func listPastEncounters() -> [URL] {
        let encountersPath = basePath.appendingPathComponent("encounters")
        
        guard let contents = try? FileManager.default.contentsOfDirectory(
            at: encountersPath,
            includingPropertiesForKeys: [.creationDateKey],
            options: [.skipsHiddenFiles]
        ) else { return [] }
        
        return contents.sorted { url1, url2 in
            url1.lastPathComponent > url2.lastPathComponent // Descending order
        }
    }
    
    func loadEncounter(from path: URL) -> EncounterState? {
        let jsonPath = path.appendingPathComponent("encounter.json")
        
        guard let data = try? Data(contentsOf: jsonPath) else { return nil }
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        
        return try? decoder.decode(EncounterState.self, from: data)
    }
    
    // MARK: - Helpers
    
    private func formatTimestamp(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm:ss"
        return formatter.string(from: date)
    }
}

