import Foundation

class EncounterStorage {
    static let shared = EncounterStorage()
    
    private let basePath: URL
    private let estTimeZone: TimeZone
    
    init() {
        basePath = FileManager.default.homeDirectoryForCurrentUser
            .appendingPathComponent("Dropbox")
            .appendingPathComponent("livecode_records")
        
        // EST timezone
        estTimeZone = TimeZone(identifier: "America/New_York") ?? TimeZone.current
        
        // Ensure directories exist
        try? FileManager.default.createDirectory(
            at: basePath.appendingPathComponent("encounters"),
            withIntermediateDirectories: true
        )
        try? FileManager.default.createDirectory(
            at: basePath.appendingPathComponent("temp"),
            withIntermediateDirectories: true
        )
        try? FileManager.default.createDirectory(
            at: basePath.appendingPathComponent("Daily Record"),
            withIntermediateDirectories: true
        )
    }
    
    // MARK: - Save Encounter
    
    func saveEncounter(_ state: EncounterState, soapNote: String, keepAudio: Bool = false) throws -> URL {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let folderName = dateFormatter.string(from: state.startedAt)
        
        let encounterPath = basePath
            .appendingPathComponent("encounters")
            .appendingPathComponent(folderName)
        
        try FileManager.default.createDirectory(at: encounterPath, withIntermediateDirectories: true)
        
        // Save encounter.json
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601
        
        let encounterJSON = try encoder.encode(state)
        try encounterJSON.write(to: encounterPath.appendingPathComponent("encounter.json"))
        
        // Save transcript.txt
        let transcriptText = state.transcript
            .map { "[\(formatTimestamp($0.timestamp))] \($0.speaker): \($0.text)" }
            .joined(separator: "\n\n")
        try transcriptText.write(
            to: encounterPath.appendingPathComponent("transcript.txt"),
            atomically: true,
            encoding: .utf8
        )
        
        // Save soap_note.txt
        try soapNote.write(
            to: encounterPath.appendingPathComponent("soap_note.txt"),
            atomically: true,
            encoding: .utf8
        )
        
        // Handle audio files
        let tempAudioPath = basePath
            .appendingPathComponent("temp")
            .appendingPathComponent(state.id.uuidString)
        
        if keepAudio {
            let audioDestPath = encounterPath.appendingPathComponent("audio")
            try? FileManager.default.moveItem(at: tempAudioPath, to: audioDestPath)
        } else {
            try? FileManager.default.removeItem(at: tempAudioPath)
        }
        
        return encounterPath
    }
    
    // MARK: - Daily Record
    
    func appendToDailyRecord(state: EncounterState, soapNote: String, patientIdentifier: String) {
        let dailyRecordPath = basePath.appendingPathComponent("Daily Record")
        
        // Create filename with date and day name (e.g., "2025-11-27_Thursday.txt")
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = estTimeZone
        dateFormatter.dateFormat = "yyyy-MM-dd_EEEE"
        let filename = dateFormatter.string(from: state.startedAt) + ".txt"
        
        let filePath = dailyRecordPath.appendingPathComponent(filename)
        
        // Format times in EST
        let timeFormatter = DateFormatter()
        timeFormatter.timeZone = estTimeZone
        timeFormatter.dateFormat = "h:mm a"
        
        let startTime = timeFormatter.string(from: state.startedAt)
        let endTime = timeFormatter.string(from: state.endedAt ?? Date())
        
        // Build the entry
        let separator = "========================================"
        let entry = """
        
        \(separator)
        Patient: \(patientIdentifier)
        Time: \(startTime) - \(endTime)
        \(separator)
        
        \(soapNote)
        
        
        """
        
        // Append to file (create if doesn't exist)
        if FileManager.default.fileExists(atPath: filePath.path) {
            // Append to existing file
            if let fileHandle = try? FileHandle(forWritingTo: filePath) {
                fileHandle.seekToEndOfFile()
                if let data = entry.data(using: .utf8) {
                    fileHandle.write(data)
                }
                fileHandle.closeFile()
            }
        } else {
            // Create new file with header
            let header = """
            Daily Record - \(dateFormatter.string(from: state.startedAt).replacingOccurrences(of: "_", with: " "))
            Generated by ClinAssist
            
            """
            let fullContent = header + entry
            try? fullContent.write(to: filePath, atomically: true, encoding: .utf8)
        }
    }
    
    func extractPatientIdentifier(from soapNote: String) -> String {
        // Extract patient identifier from SOAP note
        // Looks for "PATIENT: Name" header lines
        
        let lines = soapNote.components(separatedBy: .newlines)
        var identifiers: [String] = []
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            let uppercaseLine = trimmedLine.uppercased()
            
            // Check for "PATIENT:" header format
            if uppercaseLine.hasPrefix("PATIENT:") {
                let identifier = trimmedLine
                    .replacingOccurrences(of: "PATIENT:", with: "", options: .caseInsensitive)
                    .trimmingCharacters(in: .whitespaces)
                if !identifier.isEmpty {
                    identifiers.append(identifier)
                }
            }
        }
        
        // Remove duplicates while preserving order
        var seen = Set<String>()
        identifiers = identifiers.filter { seen.insert($0.lowercased()).inserted }
        
        if identifiers.isEmpty {
            return "Unknown Patient"
        } else if identifiers.count == 1 {
            return identifiers[0]
        } else {
            // Multiple patients - join them
            return identifiers.enumerated()
                .map { "(\($0.offset + 1)) \($0.element)" }
                .joined(separator: "; ")
        }
    }
    
    // MARK: - Clean Up Temp
    
    func cleanupTempFolder(for encounterId: UUID) {
        let tempPath = basePath
            .appendingPathComponent("temp")
            .appendingPathComponent(encounterId.uuidString)
        
        try? FileManager.default.removeItem(at: tempPath)
    }
    
    func cleanupAllTemp() {
        let tempPath = basePath.appendingPathComponent("temp")
        
        guard let contents = try? FileManager.default.contentsOfDirectory(
            at: tempPath,
            includingPropertiesForKeys: nil
        ) else { return }
        
        for item in contents {
            try? FileManager.default.removeItem(at: item)
        }
    }
    
    // MARK: - List Past Encounters
    
    func listPastEncounters() -> [URL] {
        let encountersPath = basePath.appendingPathComponent("encounters")
        
        guard let contents = try? FileManager.default.contentsOfDirectory(
            at: encountersPath,
            includingPropertiesForKeys: [.creationDateKey],
            options: [.skipsHiddenFiles]
        ) else { return [] }
        
        return contents.sorted { url1, url2 in
            url1.lastPathComponent > url2.lastPathComponent // Descending order
        }
    }
    
    func loadEncounter(from path: URL) -> EncounterState? {
        let jsonPath = path.appendingPathComponent("encounter.json")
        
        guard let data = try? Data(contentsOf: jsonPath) else { return nil }
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        
        return try? decoder.decode(EncounterState.self, from: data)
    }
    
    // MARK: - List Encounters by Date
    
    /// Lists all encounters for a specific date (in EST timezone)
    func listEncountersForDate(_ date: Date) -> [URL] {
        let encountersPath = basePath.appendingPathComponent("encounters")
        
        guard let contents = try? FileManager.default.contentsOfDirectory(
            at: encountersPath,
            includingPropertiesForKeys: nil,
            options: [.skipsHiddenFiles]
        ) else { return [] }
        
        // Get the date string prefix for the target date (in EST)
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = estTimeZone
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let targetDateString = dateFormatter.string(from: date)
        
        // Filter encounters that match the date prefix
        let matchingEncounters = contents.filter { url in
            let folderName = url.lastPathComponent
            return folderName.hasPrefix(targetDateString)
        }
        
        // Sort chronologically (ascending by folder name which includes time)
        return matchingEncounters.sorted { url1, url2 in
            url1.lastPathComponent < url2.lastPathComponent
        }
    }
    
    /// Loads the SOAP note text from a saved encounter
    func loadSOAPNote(from encounterPath: URL) -> String? {
        let soapPath = encounterPath.appendingPathComponent("soap_note.txt")
        return try? String(contentsOf: soapPath, encoding: .utf8)
    }
    
    /// Loads the transcript text from a saved encounter
    func loadTranscript(from encounterPath: URL) -> String? {
        let transcriptPath = encounterPath.appendingPathComponent("transcript.txt")
        return try? String(contentsOf: transcriptPath, encoding: .utf8)
    }
    
    /// Saves billing codes to a saved encounter
    func saveBillingCodes(_ suggestion: BillingSuggestion, to encounterPath: URL) {
        let billingPath = encounterPath.appendingPathComponent("billing_codes.json")
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        
        do {
            let data = try encoder.encode(suggestion)
            try data.write(to: billingPath)
            debugLog("Saved billing codes to \(billingPath.lastPathComponent)", component: "Storage")
        } catch {
            debugLog("âŒ Failed to save billing codes: \(error)", component: "Storage")
        }
    }
    
    /// Loads billing codes from a saved encounter
    func loadBillingCodes(from encounterPath: URL) -> BillingSuggestion? {
        let billingPath = encounterPath.appendingPathComponent("billing_codes.json")
        
        guard let data = try? Data(contentsOf: billingPath) else { return nil }
        
        return try? JSONDecoder().decode(BillingSuggestion.self, from: data)
    }
    
    /// Gets all available dates that have encounters
    func getAvailableDates() -> [Date] {
        let encountersPath = basePath.appendingPathComponent("encounters")
        
        guard let contents = try? FileManager.default.contentsOfDirectory(
            at: encountersPath,
            includingPropertiesForKeys: nil,
            options: [.skipsHiddenFiles]
        ) else { return [] }
        
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = estTimeZone
        dateFormatter.dateFormat = "yyyy-MM-dd"
        
        // Extract unique dates from folder names
        var uniqueDates = Set<String>()
        for url in contents {
            let folderName = url.lastPathComponent
            // Folder names are like "2025-12-08_14-30-00"
            let datePrefix = String(folderName.prefix(10))
            if datePrefix.count == 10 && datePrefix.contains("-") {
                uniqueDates.insert(datePrefix)
            }
        }
        
        // Convert to Date objects and sort descending
        let dates = uniqueDates.compactMap { dateString -> Date? in
            return dateFormatter.date(from: dateString)
        }
        
        return dates.sorted(by: >)
    }
    
    /// Parses the start time from an encounter folder name
    func parseEncounterTime(from encounterPath: URL) -> Date? {
        let folderName = encounterPath.lastPathComponent
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        dateFormatter.timeZone = estTimeZone
        return dateFormatter.date(from: folderName)
    }
    
    // MARK: - Helpers
    
    private func formatTimestamp(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm:ss"
        return formatter.string(from: date)
    }
}

